<!DOCTYPE html>
<html>
<body>

	<label id="age-label"></label>
	<label id="name-label"></label>
	<ul id="places-list"></ul>

	<label>x: </label>
	<label id="x-element"></label>
	
	<label>y: </label>
	<label id="y-element"></label>

	<br>
	<input id="text-input" type="text" value="test text">
	
	<br>
	<div id="image-container"></div>
	<img id="image-element">

	<script>

		// #section some util function

		// in this context array is not an object
		var isObject = function(variable) {
			return( typeof variable === "object" && variable.length === undefined )
		}

		var isArray = function(variable) {
			return( typeof variable === "object" && variable.length !== undefined )
		}

		// convert an object to an array using the values only
		var objectToArray = function(obj) {
			var arr = [];
			for(var propname in obj) { 
				arr.push(obj[propname]); 
			}

			return arr;
		}

		var camelCaseToDashed = function(word) {
			var dashCased = word[0].toLowerCase();

			for(var i = 1; i < word.length; ++i) {
				if( word[i] === word[i].toUpperCase() && word[i] !== "-")
					dashCased += "-";
				 
				dashCased += word[i].toLowerCase();
			}
			
			// trim '-' from start
			while( dashCased[0] === '-' ) {
				dashCased = dashCased.slice(1);
			}

			// trim '-' from end
			while( dashCased[dashCased.length - 1] === '-' ) {
				dashCased = dashCased.slice(0, dashCased.length - 1);
			}

			// replaces all multiple dasheses next to each other with one dash only
			return dashCased.replace(new RegExp('[-]+', 'g'), '-');
		}
		
		HTMLElement.prototype.toParent = function(parent) {
			parent.append(this);
			return this;
		}

		// #end-section

		// this will return a function which able to update the 'value' with given parameter
		// or just simply returns it
		// val: the initial value of the property (string, number, object, array)
		// boundElement: and HTMLElement which will be updated when value changes
		// attrName: this is the name of the attribute of the previous HTMLElement that will hold the value as string
		//   default is 'innerText'
		var Property = function(val, boundElement, attrName) {
			var _val = val;

			if( boundElement !== undefined ) {
				var update = Binding(boundElement, attrName);
				update(_val);
			}

			// the new value if the property if given, so acts as a setter
			// if undefined the fuction acts as a getter
			return (val) => { 
				if( val === undefined ) {
					if( typeof _val === "function" )
						return _val();
					return _val;
				}

				_val = val;
				if( update !== undefined ) {
					if( typeof _val === "function" ) {
						update(_val());
						return _val();
					}
					else {
						update(_val);
						return _val; 
					}
				}
			}			
		}

		// this returns a function as well, calling it will update the DOM wit the given values
		// element: the HTMLElement to bound value to
		// attrName: the attribute name to put the value into
		var Binding = function(element, attrName) {

			var _element = element;
			var _attrName = attrName === undefined ? "innerText" : attrName;	// default attribute is innerText

			// the value to update the DOM HTMLElement with
			return (newValue) => {
				
				// <_attrname> is string like 'innerTEXT' or 'id' or 'propsToAttrs' which is special
				if ( typeof _attrName === "string" && isObject(newValue) ) {

					// special case <newValue> is an object and its properties needs to be mapped to <_element> attributes
					if ( _attrName === "propsToAttrs" ) {
					
						for(var propName in newValue) {
							_element.setAttribute(camelCaseToDashed(propName), newValue[propName]);
						}

					// <_attrMame> in this case is a HTMLElement attribute name like 'innerText' or 'id', 'class' etc..
					// <_element> is array multiple HTMLElement need to be updated
					} else if ( isArray(_element) &&  isObject(newValue)) {

						var valAsArray = objectToArray(newValue);
						for(var i = 0; i < _element.length; ++i) {
							_element[i][_attrName] = valAsArray[i];
						}

					// basic case:
					// <_attrMame> is a attribute name
					// <_element> is a single HTMLElement
					// <newValue> is string
					} else {
						// there is difference between property and attribute.
						// _element[_attrName] = newValue; will work only if _attrName is already exist on HTMLElement
						_element.setAttribute(camelCaseToDashed(_attrName), newValue);
					}
				}
				// <_attrName> is a function that generates HTMLElement (children) and will be append to <_element> (parent)
				else if(typeof _attrName === "function") {

					// purge the parent element inside to make sure no duplicity takes place
					_element.innerHTML = "";

					// 2 cases here:
					// A: <newValue> is any array of strings
					if ( isArray(newValue) ) {
						for(var i = 0; i < newValue.length; ++i) {
							_element.append(
								_attrName(newValue[i])
							)
						}
					// B: <newValue> is string
					} else {
						_element.append(_attrName(newValue));
					}
				}
			}
		}

		// the html elements to test these are predefined
		var ageElement = document.getElementById("age-label");
		var nameElement = document.getElementById("name-label");
		var placesElement = document.getElementById("places-list");

		var xElement = document.getElementById("x-element");
		var yElement = document.getElementById("y-element");

		// one way binding: bind variables to HTMLElements in the DOM
		obj = {
			// simple binding: initial value to an existing HTMLElement, attribute will be 'innerText'
			name: Property("Adam Nagy", nameElement),
			age: Property(25, ageElement, "data-nid"),
			places: Property(
				["hungary", 123, "home", 1.5],	// initial value
				placesElement, 	// the parent HTMLElement to bind to
				(item) => {		// binding function: turn the array items to HTMLElement which then will be added to parent HTMLElement
					var ch = document.createElement("li");
					ch.innerText = item;
					return ch;
				}
			),
			complex: Property(
				{	// initial value !its an object
					x: 3,
					y: 5
				},
				[xElement, yElement],	// HTMLElement array to bind the object property to one-by-one
				"innerText"),		// the attribute to use for each HTMLElement
			image: Property(
				{
					href: "valami cÃ©l",
					dataSrc: "http://valami.hu",
					width: 450,
					height: 600
				},
				document.createElement("div").toParent(document.body),
				"propsToAttrs"
			)
		}

		// reverse binding: html element change and reflects to a variable
		HTMLElement.prototype.bindValue = function(event, variable) {
			this.addEventListener(event, variable);
		}

		var inputMirror = document.createElement("label");
		var inputModel = Property("initial", inputMirror);
		var inputElement = document.getElementById("text-input");
		inputElement.bindValue("keyup", (event) => { inputModel(event.target.value); });
		document.body.append(inputMirror);

		// more realistics demo: image
		var imageElement = document.getElementById("image-container");
		var imageModel = {
			src: Property("", imageElement, (newVal) => {
				var newImg = document.createElement("img");
				newImg.setAttribute("src", newVal);
				return newImg;
			})
		};

		var imageModel2 = {
			src: Property("", document.getElementById("image-element"), "src")
		};
		
	</script>
</body>
</html>